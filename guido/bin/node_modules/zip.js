/**
 * ZIP builder module for Nodejs.
 * 
 * @author Assen Totin assen.totin@gmail.com
 * 
 * Created for the GUIdo project, copyright (C) 2014 Assen Totin, assen.totin@gmail.com
 * Contains code by Alex, www.interstellasystems.com 
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

var fs = require('fs');
var zlib = require('zlib');
var CRC32 = require('./crc32');
var Minify = require('./minify');
var btoa = require('./btoa');

var crc32 = new CRC32();
var minify = new Minify();

var Zip = function(options) {
	// Input options (if any)
	this.options = options;
	
	// Array to store objects compressed data-related stuff (one object per compressed file)
	// This has to be an array to maintain sequential writes (i.e. calculate LOC headers offset properly). 
	this.files = [];
	
	// LOC offset counter
	this.loc_offset = 0;
	
	/**
	 * Add a file to the ZIP
	 * @param filename String The filename (with absolute or relative path) to add. 
	 * @returns boolean NULL on success, 404 on missing file. 
	 */
	this.addFile = function(filename, callback) {
		// Read the file as a Buffer
		var file = fs.readFileSync(filename);
		if (! file)
			return 404;
		
		// Modify filename as per ZIP file's final destination
		var filename_extract = filename;
		if (this.options.hasOwnProperty('prefix') && this.options.hasOwnProperty('action')) {
			if (this.options.action == 'strip') 
				filename_extract = filename.replace(this.options.prefix, '');
			else if (this.options.action == 'prepend')
				filename_extract = this.options.prefix + filename;
		}
		
		// Check if we need to create entries for any parent dir
		var parts = filename_extract.split("/");
		var parts_tmp = [];
		if (parts.length > 1) {
			for (var i=0; i<parts.length-1; i++) {
				parts_tmp.push(parts[i]);
				if (parts[i] == '.') continue;
				if (parts[i] == '..') continue;
				// Create the upstream path, check if we have an entry for it
				var path_tmp = parts_tmp.join("/");
				path_tmp += "/";
				var needs_entry = true;
				for (var j=0; j<this.files.length; j++) {
					if (this.files[j].filename == path_tmp) {
						needs_entry = false;
						break;
					}
				}
				if (needs_entry) {
					var def = {};
					def.filename = path_tmp;
					def.deflate = new Buffer(0);
					def.loc = this.createLoc(path_tmp, 0, 0, 0);
					def.cd = this.createCd(path_tmp, 0, 0, 0, this.loc_offset);
					this.files.push(def);
					this.loc_offset += def.loc.length;
				}
			}
		}
		
		// Check if we can minify before zipping (so far only for JS files):
		// TODO: add same check for template files.
		if (this.isText(this.getFileExtension(filename_extract)))
			file = minify.minifyBuffer(file);

		// Check if we need to convert binary to Base64
		else if (this.isBinary(this.getFileExtension(filename_extract))) {
			var b64;

			// String.apply() method copies all the data to the call stack and we may exceed it (it is usually 128 KB on V8);
			// if so, revert to a slower method.
			try {
		    	b64 = btoa(String.fromCharCode.apply(null, new Uint8Array(file)));
			}
			catch(e) {
			    var bytes = new Uint8Array(file);
			    var len = bytes.byteLength;
			    var binary = '';
			    for (var i = 0; i < len; i++)
			            binary += String.fromCharCode(bytes[i]);
			    b64 = btoa(binary);
			}

			file = new Buffer(b64);
		}

		// DEFLATE it
		var that = this;
		zlib.createDeflateRaw();
		zlib.deflateRaw(file, function(err, res) {			
			var def = {};
						
			def.filename = filename_extract;
			
			if (err) 
				throw new Error(err);
			
			// If deflated size is bigger than original, use the original file and STORE method
			// (otherwise some unzippers get confused why compressed size is bigger)
			var deflated_file = res;
			if (file.length < res.length) 
				deflated_file = file;
			
			def.deflate = deflated_file;
			
			// CRC32
			var crc = crc32.calc(file);
			
			// LOC
			def.loc = that.createLoc(filename_extract, crc, deflated_file.length, file.length);

			// Prepare CD
			def.cd = that.createCd(filename_extract, crc, deflated_file.length, file.length, that.loc_offset);
			
			// Save the offset at which the next file will begin
			that.loc_offset += def.loc.length + deflated_file.length;
			
			// Push the object to the array
			that.files.push(def);
			
			// Invoke the callback if such was supplied
			if (typeof callback == 'function')
				callback();
		});
	};

	/**
	 * Write the ZIP file.
	 * @param filename String The name to give (with relative or absolute path) 
	 */
	this.writeZip = function(filename) {
		var cd_size = 0;
		var total_size = 0;
		var i = 0;
		
		// Calculate sizes
		for (i=0; i<this.files.length; i++) {
			cd_size += this.files[i].cd.length;
			total_size += this.files[i].cd.length + this.files[i].loc.length + this.files[i].deflate.length;
		} 
		
		// Prepare EOCD record
		var eocd = this.createEocd(this.files.length, cd_size, this.loc_offset);
		
		total_size += eocd.length;
		
		// Assemble the LOC headers and compressed data
		var output = new Buffer(total_size);
		var output_offset = 0;
		for (i=0; i<this.files.length; i++) {
			this.files[i].loc.copy(output, output_offset);
			output_offset += this.files[i].loc.length;
			this.files[i].deflate.copy(output, output_offset);
			output_offset += this.files[i].deflate.length;
		}
		
		// Next, assemble the CD records
		for (i=0; i<this.files.length; i++) {
			this.files[i].cd.copy(output, output_offset);
			output_offset += this.files[i].cd.length;
		}
		
		// Finally, append the EOCD record
		eocd.copy(output, output_offset);
		
		// Write the new ZIP file; data is Buffer
		fs.writeFileSync(filename, output);
	};
	
	/**
	 * Create LOC header for a compressed file inside the ZIP. 
	 * @param filename String The filename (with absolute or relative path),
	 * @param crc32 String The CRC32 checksum of the compressed data.
	 * @param compressed int The size of the compressed data.
	 * @param uncompressed int The size of the uncompressed data.
	 * @returns Buffer The LOC header.
	 */
	this.createLoc = function (filename, crc32, compressed, uncompressed) {
		var loc = new Buffer(30 + filename.length);
		
		// 4 bytes: Local file header signature = 0x04034b50 (write as little-endian)
		loc.write('PK', 0);
		loc.writeUInt8(3, 2);
		loc.writeUInt8(4, 3);
		
		// 2 bytes: Version needed to extract (minimum) - set to 0x14 (this is a mapping)
		loc.writeUInt16LE(20, 4);
		
		// 2 bytes: General purpose bit flag - set to 0
		loc.writeUInt16LE(0, 6);

		// 2 bytes: Compression method - set to 8 (DEFLATE)
		(compressed < uncompressed) ? loc.writeUInt16LE(8, 8) : loc.writeUInt16LE(0, 8);
		
		// 4 bytes: date and time in ZIP's specific format
		var date = this.formatDate(new Date());
		loc.writeUInt32LE(date, 10);
		
		// 4 bytes: CRC-32
		loc.writeUInt32LE(crc32, 14);

		// 4 bytes: Compressed size
		loc.writeUInt32LE(compressed, 18);

		// 4 bytes: Uncompressed size
		loc.writeUInt32LE(uncompressed, 22);
		
		// 2 bytes: Filename length N bytes
		loc.writeUInt16LE(filename.length, 26);
		
		// 2 bytes: Extra field length - set to 0
		loc.writeUInt16LE(0, 28);

		// N bytes: Filename - set to filename
		loc.write(filename, 30);
		
		return loc;
	};
	
	/**
	 * Create CD entry for a compressed file inside the ZIP. 
	 * @param filename String The filename (with absolute or relative path),
	 * @param crc32 String The CRC32 checksum of the compressed data.
	 * @param compressed int The size of the compressed data.
	 * @param uncompressed int The size of the uncompressed data.
	 * @param loc_offset int The offset (in bytes) in which the LOC header for this file starts. 
	 * @returns Buffer The CD entry.
	 */

	this.createCd = function(filename, crc32, compressed, uncompressed, loc_offset) {
		var cd = new Buffer(46 + filename.length);
		// 4 bytes: Local file header signature = 0x02014b50 (write as little-endian)
		cd.write('PK', 0);
		cd.writeUInt8(1, 2);
		cd.writeUInt8(2, 3);
		
		// 2 bytes: Version made by - set to 0x14 (this is a mapping)
		cd.writeUInt16LE(20, 4);
		
		// 2 bytes: Version needed to extract (minimum) - set to 0x14 (this is a mapping)
		cd.writeUInt16LE(20, 6);
		
		// 2 bytes: General purpose bit flag - set to 0
		cd.writeUInt16LE(0, 8);

		// 2 bytes: Compression method - set to 8 (DEFLATE)
		(compressed < uncompressed) ? cd.writeUInt16LE(8, 10) : cd.writeUInt16LE(0, 10);;
		
		// 4 bytes: date and time in ZIP's specific format
		var date = this.formatDate(new Date());
		cd.writeUInt32LE(date, 12);
		
		// 4 bytes: CRC-32
		//cd.write(crc32, 16);
		cd.writeUInt32LE(crc32, 16);

		// 4 bytes: Compressed size
		cd.writeUInt32LE(compressed, 20);

		// 4 bytes: Uncompressed size
		cd.writeUInt32LE(uncompressed, 24);
		
		// 2 bytes: Filename length N bytes
		cd.writeUInt16LE(filename.length, 28);
		
		// 2 bytes: Extra field length - set to 0
		cd.writeUInt16LE(0, 30);
		
		// 2 bytes: File comment length - set to 0
		cd.writeUInt16LE(0, 32);

		// 2 bytes: Disk number where file starts - set to 0
		cd.writeUInt16LE(0, 34);
		
		// 2 bytes: Internal file attributes - set to 0
		cd.writeUInt16LE(0, 36);

		// 4 bytes: External file attributes - set to 0
		cd.writeUInt32LE(0, 38);

		// 4 bytes: Relative offset of LOC local file header counted from the beginning of ZIP file
		cd.writeUInt32LE(loc_offset, 42);
		
		// N bytes: Filename - set to filename
		cd.write(filename, 46);
		
		return cd;
	};
	
	/**
	 * Create the OECD record.
	 * @param count int The number of CD entries.
	 * @param size int The size (in bytes) of the CD
	 * @param cd_offset int The offset (in bytes) from the beginning of the ZIP file where CD starts. 
	 * @returns Buffer the EOCD entry.
	 */
	this.createEocd = function(count, size, cd_offset) {
		var eocd = new Buffer(22);
		
		// 4 bytes: Central directory file header signature = 0x06054b50 (write as little-endian)
		eocd.write('PK', 0);
		eocd.writeUInt8(5, 2);
		eocd.writeUInt8(6, 3);
		
		// 2 bytes: Number of this disk - set to 0
		eocd.writeUInt16LE(0, 4);
		
		// 2 bytes: Disk where central directory starts - set to 0
		eocd.writeUInt16LE(0, 6);

		// 2 bytes: Number of central directory records on this disk
		eocd.writeUInt16LE(count, 8);

		// 2 bytes: Total number of central directory records - set to same as above
		eocd.writeUInt16LE(count, 10);
		
		// 4 bytes: Size of central directory (in bytes)
		eocd.writeUInt32LE(size, 12);

		// 4 bytes: Offset of start of central directory, relative to start of ZIP file
		eocd.writeUInt32LE(cd_offset, 16);
		
		// 2 bytes: Comment length - set to 0
		eocd.writeUInt16LE(0, 20);
		
		return eocd;
	};
	
	/**
	 * Helper function to format the date and time as per the ZIP specification.
	 * @param date Date Existing date object.
	 * @returns int Integer, corresponding to the input date as per the ZIP specification. 
	 */
	this.formatDate = function(date) {
		var d = 
			(date.getFullYear() - 1980 & 0x7f) << 25 
			| (date.getMonth() + 1) << 21
			| date.getDate() << 16
			| date.getHours() << 11
			| date.getMinutes() << 5
			| date.getSeconds >> 1;
		return d;
	};
	
	
	/**
	 * Helper method to get file's extension
	 * @param filename String The filename to process
	 * @returns String The filename's extension.
	 */
	this.getFileExtension = function(filename) {
		return (/[.]/.exec(filename)) && /[^.]+$/.exec(filename)[0] || '';
	};
	
	
	/**
	 * Helper method to check if the supplied file extension is of a text file.
	 * @params extension String The extension to check.
	 * @returns boolean TRUE if the extension belongs to an text type, FALSE otherwise.  
	 */
	this.isText = function(extension) {
		extension = extension.toLowerCase();

		if (extension == 'js')
			return true;

		return false;
	};

	/**
	 * Helper method to check if the supplied file extension is of a binary file.
	 * @params extension String The extension to check.
	 * @returns boolean TRUE if the extension belongs to an binary type, FALSE otherwise.  
	 */
	this.isBinary = function(extension) {
		extension = extension.toLowerCase();

		if ((extension == 'jpg') ||
			(extension == 'jpeg') ||
			(extension == 'png') ||
			(extension == 'gif') ||
			(extension == 'svg') ||
			(extension == 'swf') ||
			(extension == 'ttf') ||
			(extension == 'woff') ||
			(extension == 'woff2') ||
			(extension == 'eot')
			)
			return true;

		return false;
	};
};

module.exports = Zip;
